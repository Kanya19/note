链接在以下三个阶段都可以执行：
编译时，即在源代码被翻译成机器代码时
加载时，即程序被加载器加载到内存并执行时
运行时，即由应用程序来执行
现代系统中，链接是由链接器自动执行的。
链接器使分离编译成为可能。


### 编译器驱动程序

编译器驱动程序可以使用户根据需要调用语言预处理器、编译器、汇编器和链接器。
通过静态链接，链接器将多个可重定位目标文件组合形成一个可执行目标文件。


### 静态链接


静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。
在构造可执行文件的过程中，链接器主要完成两个任务：
符号解析
什么是符号：目标文件定义和引用符号，每个符号对应着一个函数、全局变量或静态变量
符号解析的目的：将每个符号引用和一个符号定义关联起来
重定位
由编译器和汇编器生成的可重定位目标文件中的代码和数据节是从 0 开始的。可重定位目标文件中还包含重定位条目。
如何实现重定位：链接器通过把每个符号定义和一个内存位置（运行时地址）关联起来以实现重定位。然后修改所有对这些符号的引用，使它们指向这个内存位置。


### 目标文件
一个目标文件又称目标模块。目标文件纯粹是字节块的集合。目标文件本身是一个字节序列。
这些字节块中有些包含程序代码或程序数据，其他的则包含引导链接器和加载器的数据结构。
链接器把这些块连接起来，确定被连接块的运行时位置，并修改代码和数据块中的各种位置。

目标文件有三种形式：
可重定位目标文件：包含二进制的代码和数据。可以与其他可重定位目标文件合并成可执行目标文件。又称 obj 文件，gcc 经过预处理、编译、汇编后生成的 .o 文件即为可重定位目标文件。
可执行目标文件：包含二进制的代码和数据。可以被直接复制到内存并执行。简称可执行文件，gcc 经过链接后生成的 .out 文件以及无后缀名文件都是可执行文件。
在 linux 中，.out 文件和无后缀名文件基本意义一样，只是命名习惯的不一致而已，即 main.out 和 main 两个文件是一样的。
共享目标文件：特殊类型的可重定位目标文件，即动态链接库。可以在加载或者运行时被动态地加载进内存并链接。
静态链接库属于哪种呢？

编译器和汇编器生成可重定位目标文件和共享目标文件，链接器生成可执行目标文件。
目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。Windows 使用 PE 格式，Linux 使用 ELF 格式。


### 可重定位目标文件

本书以 Linux 中的 ELF 可重定位目标文件为例。
可重定位目标文件由多个不同的节组成，每一节都是一个连续的字节序列。指令、初始化了的全局变量、未初始化的的变量分别位于不同的节。

一个 ELF 可重定位文件中包含以下节（按位置顺序排列）：
ELF 头：特殊的节，包含文件的一些基本属性信息，用来解释目标文件和帮助链接器进行语法分析。
包含内容：生成该文件的系统的字的大小和字节顺序，ELF 头的大小，目标文件的类型，机器类型(如 x86-64)，节头部表的文件偏移，节头部表中条目的大小和数量。
.text：包含已编译程序的机器代码。即存放的是指令代码。
.rodata：包含一些特殊的只读数据。
.data：包含已初始化的全局和静态变量。
.bbs：包含未初始化的全局和静态变量，以及所有被初始化为 0 的全局或静态变量。
注意：.bss 节在目标文件中仅是一个占位符，不占据实际空间。这两类变量都是运行时在内存中为其分配变量，并初始化为 0
.symtab：包含一个符号表。存放了在程序中定义和引用的符号 (即函数和全局变量) 的信息。
注意：与可编译器中的符号表不同，.symtab 中的符号表不包含局部变量的条目。
.rel.text：包含一个 .text 节中位置的列表，当链接器把此目标文件与其他文件组合时，需要修改这些位置。
一般任何调用外部函数或引用全局变量的指令都需要修改，而调用本地函数的指令则不需要修改。为什么不需要修改呢？
注意：可执行目标文件不需要重定位，一般不包含 .rel.text 和 .rel.data 节。
理解：.rel.text 中包含的实际上是代码的重定位条目。
.rel.data：包含被模块引用或定义的所有全局变量的重定位信息。
如果一个已初始化的全局变量其初始值是一个全局变量地址或外部定义函数的地址，就需要被修改。
理解：.rel.data 中包含的实际上是已初始化的数据的重定位条目。
.debug：一个调试符号表，内部包含的条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，还有原始的 C 源文件。
注意：.debug 节并不总是存在，只有用 -g 选项来调用编译器驱动程序时，才会有这一节。
.line：包含原始 C 源程序中的行号和 .text 节中机器指令之间的映射。
注意：.line 节和 .debug 节一样，并不总是存在，只有用 -g 选项来调用编译器驱动程序时，才会有这一节。
.strtab：包含一个字符串表，其中包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。
字符串表实际上就是一个以 null 结尾的字符串的序列。
节头部表：特殊的节，是一个用来描述目标文件的节。
内容：含有与目标文件中每个节相对应的一个条目，描述了对应节的位置和大小等信息。
注意局部变量在运行时保存在栈中，既不出现在 .data 节中，也不出现在 .bss 节中。

伪节
有三个特殊的伪节，它们在节头部表中是没有条目的：
ABS：代表不该被重定位的符号
UNDEF：代表未定义的符号，即在本目标模块中引用，但在其他地方定义的符号
COMMON：表示还未被分配位置的未初始化的数据目标。
这些伪节只有可重定位文件中才有，可执行文件中没有。

COMMON 和 .bss 的区别很细微：
COMMON：未初始化的全局变量
.bss：未初始化的静态变量，初始化为 0 的全局或静态变量
原因：未初始化的全局变量是全局符号中的弱符号，编译器将其分配为 COMMON 以表明是弱符号。


### 符号和符号表

重定位的核心就是对符号表进行符号解析
每个可重定位目标模块 m 都有一个符号表（即 .symtab 节），包含着 m 定义和引用的符号的信息。

有三种不同的符号：
由模块 m 定义并能被其他模块引用的全局符号。包括非静态的函数和全局变量
由其他模块定义并被 m 引用的全局符号，称之为外部符号。对应其他模块中定义的非静态函数和全局变量。
由模块 m 定义且只能被 m 引用的局部符号。包括带 static 属性的函数和全局变量。

对照 C++ 的语法来理解什么是全局符号和局部符号（static 对全局变量和函数的隐藏效果是一样的）：
C++ 中，static 变量只能在本文件中使用，即使外其他文件中用 extern 中声明也不行。属于这里的局部符号
C++ 中，非 static 的全局变量在其他文件中也能使用，只需在该文件中用 extern 声明即可。属于这里的全局符号

注意：符号表中没有非 static 局部变量的符号，非 static 局部变量在运行时在栈中被管理。这里的局部符号和程序中的局部变量是不同的。
编译器在 .data 或 .bss 中为每个全局变量和 static 变量的定义分配空间，并在符号表中创建一个有唯一名字的符号。

符号表中的条目
符号表实际上是一个条目的数组，每个条目描述一个符号的信息。
typedef struct{
    int name;//name 是一个字符串表(.strtab节)中的字节偏移，指向符号的名字(用一个以 null 结尾的字符串表示)
    char type:4;//表明符号的类型：数据或函数（4 bits）
         binding:4;//表明符号是本地的还是全局的（4 bits）//这里的意思似乎是 type 和 binding 分别是一个 char 类型的高四位和低四位
    char reserved;//
    short section;//表明符号位于文件的哪个节中，section 是一个到节头部表的索引。
    long value;//对于可重定位文件而言，value 是距定义目标的节的起始位置的偏移；对于可执行文件而言，value 是一个绝对运行时地址
    long size;//对象的大小，以字节为单位
}
符号表中的条目除了符号外，还可以包含各个节的条目，对应原始源文件的路径名的条目。


### 符号解析

链接器解析符号引用的方法：将每个引用和它输入的可重定位文件的符号表中的一个确定的符号定义关联起来。
符号解析可以分为对局部符号的解析和对全局符号的解析：
局部符号：简单明了
备注：在每个模块中，编译器只允许每个局部符号有一个定义。并且会确保每个静态变量有唯一的名字。
全局符号：更复杂一些
方式：编译器遇到一个不是在当前模块定义的符号时，会假设该符号是在其他某个模块中定义的，在可重定位目标文件中生成一个符号表条目，并把它交给链接器处理。
特殊情况：多个目标文件中定义了相同名字的的全局符号。
这里没有说清是如何完成对局部符号的解析的，也没有说清对全局符号的解析方式

重整
链接器通过对重载函数的不同版本进行重整，将每个唯一的方法和参数列表的组合编码成一个对链接器来说唯一的名字。

#### 链接器如何解析多重定义的全局符号

编译器和汇编器会把每个全局符号区分为强或弱，并将之隐含地编码在可重定位文件地符号表里。
强符号：函数和已初始化的全局变量
弱符号：未初始化的全局变量
Linux 链接器使用以下规则来处理多重定义的全局符号：
规则1：不允许有多个同名的强符号
规则2：如果一个全符号和多个弱符号同名，那么选择强符号
规则3：如果有多个弱符号同名，任意选择其中一个
注意：vs 的链接器并未遵守规则2，规则3：如果定义了同名的全局变量，链接器会直接报错，不论是强符号还是弱符号。

#### 与静态库链接

可以将多个相关的目标模块打包成一个单独的文件，称为静态库。
通过静态库，相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。
静态库可以用作链接器的输入。链接器在构造可执行文件时，从静态库中复制被应用程序引用的目标模块，其他未用到的模块则不会复制。
在 Linux 系统中，静态库以一种称为存档的特殊文件格式存放磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件后缀名为 .a 。
理解：静态库和存档文件可以当作一个东西。存档是文件层面的描述，静态库是模块层面的描述。
在 linux 中，静态链接库是 .a 文件，动态链接库是 .so 文件。在windows 中，静态链接库是 .lib 文件，动态链接库是 .dll 文件。
静态库的应用实例

通过如下命令创建静态库：
linux> gcc -c addvec.c multvec.c   //将 addvec.c 和 multvec 两个文件编译成两个可重定位目标文件
linux> ar rcs libvector.a addvec.o multvec.o  //采用 ar 工具将上一步生成的两个可重定位目标文件 addvec.o 和 multvec.o 封装到静态库 libvector.o 中。

#### 链接器如何解析引用

符号解析的过程
在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。
在扫描中，链接器会维护一个可重定位目标文件的集合 E，一个未解析的符号 (即引用了但尚未定义的符号) 集合 U，已定义的符号集合 D。初始时 E, U, D 都为空。
对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文件。
如果 f 是一个目标文件，链接器会把 f 添加到 E，修改 U 和 D 来反映 f 中的符号定义和引用，并继续下一个输入文件。
如果 f 是一个存档文件，链接器会尝试匹配 U 中未解析的符号和存档文件成员定义的符号。
如果 f 中的某个成员 m 定义了一个符号来解析 U 中的一个引用，就把 m 加到 E 中，并修改 U 和 D 来反映 m 中的符号定义和引用。
对存档文件中所有的成员目标文件都依次进行这个过程。之后任何不包含在 E 中的成员目标文件都简单地被丢弃。
处理完 f，链接器会继续处理下一个输入文件。
当链接器扫描完所有输入文件后，如果 U 是非空的，链接器会输出一个错误并终止。

库在命令行中放在什么位置
在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件前，引用就不能被解析，链接会失败。因为初始时 U 是空的。
一般把库放在命令行的结尾。如果库之间相互依赖，则依赖者在前，被依赖者在后。如果双向引用，可以在命令行上重复库。