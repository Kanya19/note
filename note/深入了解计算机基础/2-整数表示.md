整数可以分为两种：有符号和无符号。而具体的数值由其位数来决定。例如C中有char，short，int，long等。

Java只支持有符号数，不支持无符号数。


无符号和二进制补码编码

最靠近0的负数，即负1，映射为最大的无符号数。另一端最小的负数映射为一个刚好在二进制补码表示的正数范围之外的无符号数。

 C中的有符号与无符号

 注意：如果两个比较的数值中一个有符号，一个无符号，则在C语言中，将默认将有符号的数值转换成无符号后比较，所以可能会产生一些不符合直接的比较，比如 -1 > 0U 表达式是成立的。

同样的，有符号数在循环中的使用需要特别注意，以免产生无法停止的循环，避免这类错误的一种方法是不要在循环中使用无符号数。例如：

    // length为外部传入的unsigned参数，如果length为0，则下面循环要循环intmax次。
    for (int i = 0; i < length - 1; ++i)


扩展一个数字的位显示

比如char转short，short转int，就是扩展位。

>无符号数位扩展，高位填0
>有符号扩展，高位填最高位数值。同负数的右移操作。填充高位方可使补码表示的值不变。

 截断数字

    刚入们的程序可能会非常惊奇的发现，两个正数相加会的到一个负数，比较表达式，x < y 与 x - y < 0 会产生不同的结果。这些属性是计算机运算的有限性造成的。

两个正数相加会的到一个负数，比较表达式，x < y 与 x - y < 0 会产生不同的结果。这些属性是计算机运算的有限性造成的。

### 无符号加法 
对于s = x + y；如何判断s是否发生过溢出？简单来说就是 判断 s < x 或者 s < y 如果成立则表示发生了溢出。证明如下：假设x + y溢出，则 s = x + y - 2^w ; 由于 [公式] ，所以 y - 2^w < 0，可得 s < x；此对无符号数有效
### 二进制补码加法
    对于数值执行二进制加法，然后直接截断到指定位数，即可得到想要的结果。
    无论有符号无符号，二进制加法都是直接按位相加，超出最大位的就丢掉就对了。

### 二进制补码的非

二进制补码的非，即逆元，一般而言，x的逆元为-x。

注意：对于 [公式] , -x不是它的加法逆元，因为 [公式] 是w位无法表达的正数 。所以特别申明，这个特殊值的本身就是它的逆元。

一种有名的用来计算二进制补码的非的方法是，对每个位取反之后加1，即 -x = ~x+1。

### 乘以2的幂 2.3.7 除以2的幂
乘以2的幂可以直接视为左移，左移统一规则是右侧补0 。 无符号数可能导致符号位变化。

无符号数除以2的幂，直接进行右移，高位补0即可得到想要的结果。有符号数值，当x>=0时，右移可以得到想要的结果，而当x<0或者y<0时，右移的结果却有所偏差，例如-5/2 得到的结果应该是-2，而二进制[1011] 右移一位之后得到[1101]结果是-3并不是我们想要的结果(注意负数右移采用算术右移，高位复制)。也就是说：整数除法应该将负的结果向0方向舍入。 可以通过一个小技巧来处理，那就是 x/y = (x + y - 1)/y的方式向上取整