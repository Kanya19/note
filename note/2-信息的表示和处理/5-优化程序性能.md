### 优化编译器的能力和局限性

>现代编译器非常的强大，拥有非常复杂的优化算法，但是也并非无所不能。要想开始优化，我们首先得对编译器能做到什么，做不到什么，有一个了解。因为知道了编译器的一些局限性才能更好的配合写出高效的代码。

现代编译器使用复杂精细的算法来优化，例如减少一个计算的次数，使用中间值来代替。但是这些优化受到一些因素的限制，包括：

绝对不能改变程序的行为

他们对程序行为、使用环境了解有限

需要很快的完成编译

以下面的代码为例：

>void twiddle1(int *xp, int *yp) {
    *xp += *yp;
    *xp += *yp;
}
>
>void twiddle2(int *xp, int *yp) {
    *xp += 2 * *yp;
}

如果函数f中有些副作用，例如计数器，则上面两个方法就不等效了。这种情况下只能有程序员来优化，编译器是没法处理的。

>因为存储器别名和函数本身的复杂性，编译器为了保证优化不改变行为，只能采取保守策略。所以上面这两个案例，只能由程序员来优化了。你可能要说了，谁会写出这么明显垃圾的代码啊？ 当然这是一个示例，现实中的代码可能在层层的屏障之中，让人无法一眼看到其本质，那么会写出类似的代码。

### 表示程序性能
CPE：cycles per element , 每元素的周期数。主要用于在迭代上考察单个元素的性能。

为了讨论性能，为了后面能够让人直观的看到性能的提升，CPE这个概念应当牢记。例如循环有10个元素，耗时100个时钟周期，则CPE = 100 / 10 ;
处理器活动的顺序是由时钟控制的，时钟提供固定频率的信号，一般用MHz，GHz来表示。用时钟周期来表示度量标准比较利于我们理解机器的运行情况。

###程序示例
本节主要是展示了一段代码，后续的一些优化方法都是基于该代码，下面展示主要的函数：

// 这里使用宏不是故弄玄虚，是为了便于测试加法和乘法对比，后续的效率对比都会对比两种操作
#define IDENT 0
#define OPER +
int vec_length(vec_ptr v) {
    return v->len;
}
int get_vec_element(vec_ptr v, long index, data_t *dest) {
    if (index < 0 || index >= v->len)
        return 0;
    *dest = v->data[index];
    return 1;
}
void combin1(vec_ptr v, data_t *dest) {
    int i;
    *dest = IDENT;
    for (i = 0; i < vec_length(v); i++) {
        data_t val;
        get_vec_element(v, i, &val);
        *dest = *dest OPER val;
    }
}


#### 消除循环的低效率]

#### 减少过程调用

#### 消除不必要的存储器引用

#### 寄存器重命名
所谓寄存器重命名就是一种减少寄存器读写等待的技术，一个要写寄存器的操作，可能因为是在预测分支中，无法直接写入，需要等待后续确认之后才能写入，那么该分支上后续指令需要使用这个寄存器，那么就在一张特定的表中取查询该值，从而跳过等待。即使没有分支预测，也能加快指令的执行，无需等待写入。

>这个设计可以考虑怎么利用到项目中，对于那些更新数据会引起一连串变化的操作，可以进行数据缓存，把实际的更新延后。而取数据的时候需要先检测缓存。