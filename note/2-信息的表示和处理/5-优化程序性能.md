### 优化编译器的能力和局限性

>现代编译器非常的强大，拥有非常复杂的优化算法，但是也并非无所不能。要想开始优化，我们首先得对编译器能做到什么，做不到什么，有一个了解。因为知道了编译器的一些局限性才能更好的配合写出高效的代码。

现代编译器使用复杂精细的算法来优化，例如减少一个计算的次数，使用中间值来代替。但是这些优化受到一些因素的限制，包括：

绝对不能改变程序的行为

他们对程序行为、使用环境了解有限

需要很快的完成编译

以下面的代码为例：

>void twiddle1(int *xp, int *yp) {
    *xp += *yp;
    *xp += *yp;
}
>
>void twiddle2(int *xp, int *yp) {
    *xp += 2 * *yp;
}

如果函数f中有些副作用，例如计数器，则上面两个方法就不等效了。这种情况下只能有程序员来优化，编译器是没法处理的。

>因为存储器别名和函数本身的复杂性，编译器为了保证优化不改变行为，只能采取保守策略。所以上面这两个案例，只能由程序员来优化了。你可能要说了，谁会写出这么明显垃圾的代码啊？ 当然这是一个示例，现实中的代码可能在层层的屏障之中，让人无法一眼看到其本质，那么会写出类似的代码。

### 表示程序性能
CPE：cycles per element , 每元素的周期数。主要用于在迭代上考察单个元素的性能。

为了讨论性能，为了后面能够让人直观的看到性能的提升，CPE这个概念应当牢记。例如循环有10个元素，耗时100个时钟周期，则CPE = 100 / 10 ;
处理器活动的顺序是由时钟控制的，时钟提供固定频率的信号，一般用MHz，GHz来表示。用时钟周期来表示度量标准比较利于我们理解机器的运行情况。

###程序示例
本节主要是展示了一段代码，后续的一些优化方法都是基于该代码，下面展示主要的函数：

// 这里使用宏不是故弄玄虚，是为了便于测试加法和乘法对比，后续的效率对比都会对比两种操作
#define IDENT 0
#define OPER +
int vec_length(vec_ptr v) {
    return v->len;
}
int get_vec_element(vec_ptr v, long index, data_t *dest) {
    if (index < 0 || index >= v->len)
        return 0;
    *dest = v->data[index];
    return 1;
}
void combin1(vec_ptr v, data_t *dest) {
    int i;
    *dest = IDENT;
    for (i = 0; i < vec_length(v); i++) {
        data_t val;
        get_vec_element(v, i, &val);
        *dest = *dest OPER val;
    }
}


#### 消除循环的低效率]

#### 减少过程调用

#### 消除不必要的存储器引用

#### 寄存器重命名
所谓寄存器重命名就是一种减少寄存器读写等待的技术，一个要写寄存器的操作，可能因为是在预测分支中，无法直接写入，需要等待后续确认之后才能写入，那么该分支上后续指令需要使用这个寄存器，那么就在一张特定的表中取查询该值，从而跳过等待。即使没有分支预测，也能加快指令的执行，无需等待写入。

>这个设计可以考虑怎么利用到项目中，对于那些更新数据会引起一连串变化的操作，可以进行数据缓存，把实际的更新延后。而取数据的时候需要先检测缓存。


#### 处理器操作的抽象模型

从这个图上，就能够看得出来，mul操作跟load，add操作是并行的。从上面的表格可以看到combine4浮点数的延迟为5.01，而浮点的mul的延迟正是5.0，这就是说mul是整个瓶颈，其他操作都是和mul并行执行的。

>并行！指令集的并行，一些并不互相依赖的操作是可以并行执行的，占用的时间也就忽略不计了。这就解释了前面的第一个问题，为什么优化了一个函数调用居然没有效果，就是因为之前内存的访问是瓶颈，其他的操作在内存访问的同时可能就完成了。

第一个方法需要的加法为degree次，乘法则是2*degree次。而第二个方法乘法变为degree次，足足减少了一倍。然而实际测试中，方法一的CPE为5.0，而方法二的CPE为8.0。

这是因为方法一种两个乘法操作实际上可以并行操作，瓶颈实际上是xpwr = x * xpwr;。在此操作期间上面的加法并行的执行完成了。而方法二中的乘法计算要依赖result，没法实现并行运算，需要算完乘法，再算加法，更新寄存器，然后才能开始下次循环。

循环展开
前面简单介绍了什么叫循环展开，这一节正式的介绍如何使用循环展开来优化。

循环展开即增加每次迭代计算元素的数量，从而减少迭代的次数。循环展开从下面两方面改进性能：

减少操作数量，例如计算索引和条件判断

提供了后续进一步优化代码的空间以便减少关键路径上操作的数量。
