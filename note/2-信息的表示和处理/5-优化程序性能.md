### 优化编译器的能力和局限性

>现代编译器非常的强大，拥有非常复杂的优化算法，但是也并非无所不能。要想开始优化，我们首先得对编译器能做到什么，做不到什么，有一个了解。因为知道了编译器的一些局限性才能更好的配合写出高效的代码。

现代编译器使用复杂精细的算法来优化，例如减少一个计算的次数，使用中间值来代替。但是这些优化受到一些因素的限制，包括：

绝对不能改变程序的行为

他们对程序行为、使用环境了解有限

需要很快的完成编译

以下面的代码为例：

>void twiddle1(int *xp, int *yp) {
    *xp += *yp;
    *xp += *yp;
}
>
>void twiddle2(int *xp, int *yp) {
    *xp += 2 * *yp;
}

如果函数f中有些副作用，例如计数器，则上面两个方法就不等效了。这种情况下只能有程序员来优化，编译器是没法处理的。

>因为存储器别名和函数本身的复杂性，编译器为了保证优化不改变行为，只能采取保守策略。所以上面这两个案例，只能由程序员来优化了。你可能要说了，谁会写出这么明显垃圾的代码啊？ 当然这是一个示例，现实中的代码可能在层层的屏障之中，让人无法一眼看到其本质，那么会写出类似的代码。

### 表示程序性能
CPE：cycles per element , 每元素的周期数。主要用于在迭代上考察单个元素的性能。

为了讨论性能，为了后面能够让人直观的看到性能的提升，CPE这个概念应当牢记。例如循环有10个元素，耗时100个时钟周期，则CPE = 100 / 10 ;
处理器活动的顺序是由时钟控制的，时钟提供固定频率的信号，一般用MHz，GHz来表示。用时钟周期来表示度量标准比较利于我们理解机器的运行情况。