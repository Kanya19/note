## 异常控制流
从给处理器加电开始，到断电为止，程序计数器假设一个值的序列：a0, a1, a2, ..., an。其中每个 a(k) 都是某个相应的指令 I(k) 的地址。
每次从 a(k) 到 a(k+1) 的过渡称为控制转移。这样的控制转移序列叫做处理器的控制流（control flow）。
最简单的控制流是一个平滑的序列，其中每个 I(k) 和 I(k+1) 都是相邻的。而诸如跳转、调用、返回等指令则会造成平滑流的突变，这些突变是由程序内部变量带来的。
还有一种突变是由程序外部的原因造成的，比如磁盘返回数据，鼠标关闭程序等，这种突变就叫做异常控制流（Exceptional Control Flow, ECF）。
异常控制流 ECF 发生在计算机系统的各个层次：
硬件层，硬件中断
操作系统层，内核通过上下文切换将控制从一个进程转移到另一个进程
应用层，一个进程给另一个进程发送信号，信号接收者将控制转移到信号处理程序。
ECF 的应用：
操作系统内部。ECF 是操作系统用来实现 I/O、进程和虚拟内存的基本机制。
与操作系统交互。应用程序通过使用一个叫做系统调用（system call）的 ECF 形式，向操作系统请求服务。
编写应用程序。操作系统为应用程序提供了 ECF 机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件、检测和响应这些事件。
并发。ECF 是计算机系统中实现并发的基本机制。并发的例子有：异常处理程序或信号处理程序中断应用程序的执行，时间上重叠执行的进程和线程。
软件异常处理。C++ 和 Java 通过 try、catch、throw 等语句来提供异常处理功能。异常处理允许程序进行非本地跳转（即违反通常的调用/返回栈规则的跳转）来响应错误情况。非本地跳转是一种应用层 ECF，在 C 中由 setjmp和 longjmp 函数提供。
理解：首先要知道，异常控制流是从程序计数器的控制流层面来描述的。异常控制流就是程序计数器的控制流产生了程序外部原因带来的突变。


#### 异常
异常（exception）是异常控制流的一种形式，一部分由硬件实现（也因此它的具体细节会随系统的不同而有所不同），一部分由操作系统实现。异常位于硬件和操作系统交界的部分。
注意：这里的异常和 C++ 或 Java 中的应用级异常是不同的。
异常就是控制流中的突变，用来响应处理器状态中的某些变化。在处理器中，状态被编码为不同的位和信号，状态变化称为事件（event）。

任何情况下，当处理器检测到有事件发生时，就会通过一张叫做异常表的跳转表，进行一个间接过程调用（异常），到异常处理程序（操作系统中一个专门用来处理这类事件的子程序）中。
事件的例子：发生虚拟内存缺页、算术溢出、一条指令试图除以 0、一个系统定时器产生的信号等。
当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：
处理程序将控制返回给当前指令 I(curr)，即事件发生时正在执行的指令。
处理程序将控制返回给下一条指令 I(next)，即如果没有发生异常将会执行的下一条指令。
处理程序终止被中断的程序。

#### 异常处理

系统为每种可能的异常都分配了一个唯一的非负整数的异常号：
一部分异常号是处理器设计者分配的（对应硬件部分）。比如被零除、缺页、内存访问违例、断点、算术溢出。
另一部分是由操作系统内核的设计者分配的（对应软件部分）。比如系统调用、来自外部 I/O 设备的信号。
在系统启动时，操作系统分配和初始化一张异常表，使得表目 k 包含异常 k 的处理程序的地址。

系统在执行某个程序时，处理器检测到发生了一个事件，并确定了对应的异常号 k，就会触发异常。
触发异常：执行间接过程调用，通过异常表的表目 k，转到相应的处理程序。异常号是到异常表中的索引，异常表的起始地址放在一个特殊 CPU 寄存器——异常表基地址寄存器中。

异常类似过程调用，但有一些不同：
过程调用时，在跳转到处理程序前，处理器将返回地址压入栈中。而在异常中，返回地址是当前指令（事件发生时正在执行的指令）或下一条指令。
处理器也会把一些额外的处理器状态压入栈中，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。。
如果控制从用户程序转移到内核，所有这些项目都被压倒内核栈中，而不是用户栈中。
异常处理程序运行在内核模式下，因此它们对所有的系统资源都有完全的访问权限。
一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中执行。
异常处理结束后，会执行一条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，然后将控制返回给别终端的程序。

#### 异常的类别

异常可以分为 4 类：
中断：来自 I/O 设备的信号；异步
陷阱：有意的异常；同步
故障：潜在的可恢复的错误；同步
终止：不可恢复的错误；同步
中断是异步异常，异步异常是由处理器外部的 I/O 设备中的事件产生的。
陷阱、故障和终止都是同步异常，它们是执行一条指令（称为故障指令）的直接产物。因为指令是按时钟周期执行的，所以由指令造成的异常必然是同步的。
总结：简单而言，异常可以分为异步和同步两类，其中异步的异常是来自外部的 I/O 设备，同步的异常则都是指令的产物。

中断
中断是异步异常，是由处理器外部的 I/O 设备中的事件产生的。硬件中断不是由指令造成的，因此它是异步的。硬件中断的异常处理程序常常叫做中断处理程序。
I/O 设备向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上来触发中断。异常号标识了引起中断的设备。
在当前指令完成执行后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，调用对应的中断处理程序。
陷阱和系统调用
陷阱是有意的异常，是执行一条指令的结果。
陷阱最重要的用途是在应用程序和内核之间提供一个接口，叫做系统调用。
系统提供了一条特殊的 ”syscall n“ 指令，当用户程序想要向内核请求服务 n 时，就执行这条指令。执行 syscall 指令会导致一个到异常处理程序的陷阱（异常），这个处理程序解析参数，并调用适当的内核程序。
用户程序经常需要向内核请求服务，比如读文件（read）、创建进程（fork）、加载程序（execve）、终止进程（exit）等。
从程序员角度看，系统调用和普通的函数调用是一样的。但是实现上大不相同。
故障
故障由错误情况引起。故障发生时，处理器将控制转移给故障处理程序，如果处理程序能够修正错误，就把控制返回到引起故障的指令，否则返回给内核中的 abort 例程，abort 会终止当前的应用程序。
缺页异常
缺页异常是一种经典的故障（页面是虚拟内存中一个连续的块，典型值是 4KB）。当指令引用一个虚拟地址，而与该地址对应的物理页面不在内存中，必须要从磁盘取出时，就会发生缺页异常。
然后缺页处理程序会从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面就在内存中了。
理解：从存储器层次结构的角度看，缺页异常似乎可以看作是内存不命中的惩罚。
终止
终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。终止处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。
理解：运行程序时遇到了 abort 表明发生了故障或终止异常。

####  Linux/x86-64系统中的异常

x86-64 系统中有 256 种不同的异常类型，其中 0~31 号是 Intel 架构师定义的异常，剩下的是操作系统定义的中断和陷阱。
理解：0-31 号是故障或终止，32~255 号都是操作系统定义的中断或系统调用。

Linux/x86-64 故障和终止
除法错误。当应用试图除以零时，或者当一个除法指令的结果对目标操作数来说太大了，就会发生除法错误。
当发生除法错误，Unix 会直接终止程序，Linux shell 通常把除法错误报告为“浮点异常(Floating Exception)”。
一般保护故障。有许多原因，通常是因为一个程序引用了一个未定义的虚拟内存区域，或试图写一个只读的文本段。
此类故障也不会恢复，Linux shell 通常会把一般保护故障报告为“段故障(Segmentation fault)”。
缺页异常。此类故障会尝试恢复并重新执行产生故障的指令。
机器检查。在告知故障的指令执行中检测到致命的硬件错误时发生。
此类故障从不返回控制给应用程序。
Linux/x86-64 系统调用
Linux 提供几百种系统调用，供应用程序请求内核服务时使用。（其中有一部分在 unistd.h 文件中）
系统中有一个跳转表（类似异常表）。每个系统调用都有一个唯一的整数号，对应一个到内核中跳转表的偏移量。
C 程序使用 syscall 函数可以直接调用任何系统调用。但是没必要这么做，C 标准库为大多数系统调用提供了包装函数。这些包装函数也是系统级函数。
所有 Linux 系统调用的参数都是通用寄存器而不是栈传递的。一般寄存器 %rax 包含系统调用号。
系统调用是通过陷阱指令 syscall 进行的（这里的 syscall 指令是汇编级别的指令）。 


'系统级函数写 helloworld'
>int main()
>
>{
>
>    write(1, "hello, world\n", 13);
> 
>    _exit(0);
> 
>}
>
>main:
>
>    movq $1, %rax
> 
>    syscall


### 进程

异常是允许操作系统内核提供进程概念的基本构造块。
进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。
上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、打开文件描述符的集合。
当用户向 shell 输入一个可执行目标文件的名字，运行程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行该可执行文件。
进程提供给应用程序的关键抽象：
一个独立的逻辑控制流。好像程序独占地使用处理器。
一个私有的地址空间。好像程序独占地使用内存。

#### 逻辑控制流

使用调试器单步执行程序时会看到一系列的程序计数器（PC）值，这个 PC 的值的序列叫做逻辑控制流，简称逻辑流。
PC 的值唯一地对应于包含在程序的可执行目标文件中的指令，或包含在运行时动态链接到程序的共享对象中的指令。
逻辑流有许多不同的形式，异常处理程序、进程、信号处理程序、线程等都是逻辑流的例子。

进程是轮流使用处理器的。

#### 并发流

当一个逻辑流的执行在时间上与另一个流重叠，就称为并发流，这两个流称为并发地运行。
并行流是并发流的真子集，如果两个流并发地运行在不同的处理器核或不同的计算机上时，就称为并行流。
一个进程和其他进程轮流运行的概念叫做多任务。
一个进程执行它的控制流的一部分的每一时间段叫做时间片。如 8.2.1 的图中的进程 A 包含两个时间片。

#### 私有地址空间

进程为每个程序提供它自己的私有地址空间。一般而言，和这个私有地址空间中某个地址相关联的那个内存字节是不能被其他进程读或写的。
不同进程的私有地址空间关联的内存的内容一般不同，但是每个这样的空间都有相同的通用结构。
x86-64 Linux 进程的地址空间的组织结构
地址空间的顶部保留给内核（操作系统常驻内存的部分），包含内核在代表进程执行指令时（比如当执行了系统调用时）使用的代码、数据、堆和栈。
地址空间的底部留给用户程序，包括代码段、数据段、运行时堆、用户栈、共享库等。代码段总是从地址 0x400000 开始。
理解：可以看出，内核栈和用户栈是分开的。

#### 用户模式和内核模式

处理器使用某个控制寄存器中的一个模式位（mode bit）来区分用户模式与内核模式。进程初始时运行在用户模式，当设置了模式位时，进程就运行在内核模式。
运行在内核模式的进程可以执行指令集中的任何指令，并可以访问系统中的任何内存位置。
运行在用户模式的进程不允许执行特权指令，比如停止处理器、改变模式位、发起 I/O 操作等，也不能直接引用地址空间内核区中的代码和数据，用户程序只能通过系统调用接口间接地访问内核代码和数据。
进程从用户模式变为内核模式的方法是通过中断、故障、陷阱（系统调用就是陷阱）这样的异常。异常发生时，控制传递给异常处理程序，处理器将模式从用户模式转变为内核模式。
/proc 文件系统
Linux 提供了一种叫做 /proc 文件系统的机制来允许用户模式进程访问内核数据结构的内容。
/proc 文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。
可以通过 /proc 文件系统找出一般的系统属性（如 CPU 类型：/proc/cpuinfo）或者某个特殊的进程使用的内存段
2.6 版本的 Linux 内核引入了 /sys 文件系统，它输出关于系统总线和设备的额外的低层信息。

#### 上下文切换

上下文切换是一种较高层形式的异常控制流，它是建立在中断、故障等较低层异常机制之上的。
系统通过上下文切换来实现多任务。
内核为每个进程维持一个上下文，上下文是内核重新启动一个被挂起的进程所需的状态。
上下文由一些对象的值（是这些对象的值而非对象本身）组成，这些对象包括：通用目的寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈、内核栈和各种内核数据结构（如描述地址空间的页表、包含有关当前进程信息的进程表、包含进程已打开文件的信息的文件表）。
内核挂起当前进程，并重新开始一个之前被挂起的进程的决策叫做调度，是由内核中的调度器完成的。
内核使用上下文切换来调度进程：
保存当前进程的上下文
恢复某个先前被抢占的进程被保存的上下文
将控制传递给这个新恢复的进程
当内核代表用户执行系统调用时，可能发生上下文切换。如果系统调用因为等待某个事件而阻塞（比如 sleep 系统调用显式地请求让调用进程休眠，或者一个 read 系统调用要从磁盘度数据），内核就可以让当前进程休眠，切换到另一个进程。即使系统调用没有阻塞，内核也可以进行上下文切换，而不是将控制返回给调用进程。
中断也可能引发上下文切换。如所有的系统都有一种定时器中断机制，即产生周期性定时器中断，通常为 1ms 或 10ms。当发生定时器中断，内核就判定当前进程已经运行了足够长时间，该切换到新的进程了。