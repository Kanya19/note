## 虚拟内存

>虚拟内存为每个进程提供了一个大的、一致的和私有的地址空间。
虚拟内存提供了三个重要能力：
将主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存中传送数据。
为每个进程提供了一致的地址空间，简化了内存管理。进而简化了链接、进程间共享数据、进程的内存分配、程序加载。
保护了每个进程的地址空间不被其他进程破坏。
虚拟内存的几个特点：
虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中都扮演着重要角色。
虚拟内存给予应用程序强大的能力，可以创建和销毁内存片（chunk），将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存。
虚拟内存很危险。每次应用程序引用一个变量、间接引用一个指针或调用一个如 malloc 的动态分配程序时，都会和虚拟内存交互，如果使用不当就会发生错误。


#### 物理和虚拟寻址

主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。CPU 访问内存最自然的方式就是使用物理地址，称为物理寻址。
现代 CPU 使用的是虚拟寻址：CPU 通过生成一个虚拟地址（VA）来访问主存，这个虚拟地址首先通过地址翻译转换为物理地址。
地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上名为内存管理单元（MMU）的专用硬件利用存放在主存中的查询表来动态翻译虚拟地址。

#### 地址空间

地址空间是一个非负整数地址的有序集合：{0, 1, 2, ...}
如果地址空间中的整数是连续的，就称为线性地址空间。
在计算机系统中，CPU 从一个有 N=2^n 个地址的地址空间中生成虚拟地址空间。
一个地址空间的大小是由表示地址的位数来描述的，例如现代的 64 位计算机一般支持 64 位虚拟地址空间。
主存中的每个字节都有一个虚拟地址和一个物理地址。

#### 虚拟内存作为缓存的工具

虚拟内存作为磁盘的高速缓存，和存储器层次结构中的其他缓存一样，磁盘（较低层）中的数据被分割成块，作为磁盘和主存（较高层）之间的传输单元。
VM（虚拟内存）系统通过将虚拟内存分割为虚拟页（Virtual Page，VP）来处理此问题。每个虚拟页的大小为 P=2^p。
类似的，物理内存被分割为物理页（PP），大小也是 P 字节。物理页也被称为页帧。
任何时刻，所有的虚拟页都被分为了三个不相交的子集：
未分配的：VM 系统还未分配（未创建）的页。未分配的块没有任何数据与它们相关联，因此不占用任何磁盘空间。
已缓存的：当前已缓存在物理内存中的已分配页。
未缓存的：未缓存在物理内存中的已分配页。


#### DRAM缓存的组织结构

主存一般采用 DRAM，DRAM 与磁盘之间的速度差要比 SRAM 与 DRAM 之间的速度差大很多，并且从磁盘的一个扇区读取第一个字节的时间开销比读这个扇区中的连续字节要慢很多。因此 DRAM 缓存的组织结构与高速缓存有很大不同。
因为严重的不命中处罚和访问第一个字节的开销，虚拟页一般很大，通常在 4KB~2MB，且 DRAM 缓存是全相联的，即任何虚拟页都可以放在任何的物理页中。不命中时的替换策略也很重要。
因为访问磁盘很慢，所以 DRAM 都采用写回（即延时写），而非直写。

#### 页表

VM 系统需要判定一个虚拟页是否缓存在 DRAM 中的某个地方，如果是需要确定虚拟页存放在哪个物理页中，如果不是需要判断虚拟页存放在磁盘的哪个位置；在 DRAM 中选择一个牺牲页并把虚拟页从磁盘复制到 DRAM 中替换这个牺牲页。
这些功能由操作系统软件、MMU 中的地址翻译硬件、页表共同完成：
页表是一个存放在 DRAM 中的数据结构，它将虚拟页映射到物理页。
每次地址翻译硬件将一个虚拟地址转换为硬件地址时都会读取页表。
操作系统负责维护页表的内容，以及在磁盘和 DRAM 间传送页。
页表是一个页表条目（PTE）构成的数组，虚拟地址空间中的每个页在页表中的一个固定偏移量处都有一个 PTE。可以认为 PTE 由一个有效位和一个 n 位地址字段组成。有效位表明该虚拟页是否被缓存在 DRAM 中。
对于三种不同的页，其页表条目的内容不同：
已缓存的页：有效位=1，n 位地址字段表示该页在 DRAM 中相应的物理页的起始地址。
未缓存的页：有效位=0，n 位地址字段表示该虚拟页在磁盘上的起始地址。
未分配的页：有效位=0，地址字段为空。


#### 页命中

例如当 CPU 要读取上图中的 VP2 就会发生页命中。
地址翻译硬件使用虚拟地址作为索引从页表中查找相应的页表条目，然后读取条目中的内容来获取该虚拟页在 DRAM 中的物理地址。

#### 缺页

DRAM 缓存不命中称为缺页。如 CPU 要读取上图中的 VP3 时，会从页表条目的有效位发现该页没有被缓存。
当发生缺页会触发一个缺页异常。缺页异常会调用内核中的缺页异常处理程序，该程序会从已缓存的页中选择一个牺牲页。如果该牺牲页之前已经被修改，内核会先将它复制回磁盘（即写回），然后内核会占用它的物理页并修改它的页表条目为未缓存的。
缺页异常处理完成后，会重新启动导致缺页的指令，该指令重新进行对该虚拟地址的操作。

#### 分配页面

初始的虚拟地址空间中的虚拟页基本都是未分配的，当调用了 malloc 就会分配一个或一些新的虚拟页，这些页指向磁盘上的对应页面。
理解：或许是因为 malloc 只负责分配内存，不负责创建对象，所以 malloc 分配得到的页是未缓存的。


#### 又是局部性救了我们

虚拟内存利用了局部性。
通过将活动页面集合（称为工作集）缓存到 DRAM 中来减少出现缺页的情况。
如果工作集的大小超出了 DRAM 的大小，程序将会发生抖动，页面会不断地换进换出。
根据本节内容可以区分主存缓存与各高速缓存的组织结构的不同之处：
高速缓存将地址位划分为有效位、标记位、组索引位、块偏移位，通过组选择、行匹配、字抽取来完成对数据的操作。
主存采用了 VM 系统，使用页表来实现对数据的查找。


### 虚拟内存作为内存管理的工具

实际上每个进程都会有一个独立的虚拟地址空间，也都有一个独立的页表。不同进程的虚拟页面可能映射到同一个物理页面上。
通过按需页面调度与独立的虚拟地址空间，VM 在内存管理时实现了以下功能：
简化链接。独立的地址空间允许为每个进程的内存映像使用相同的基本格式，如代码段都是从 0x400000 开始，数据段都在代码段后，栈从用户进程地址空间最高的地方向下生长等。因为采用了虚拟地址，所以这些可执行文件是独立于物理内存中代码和数据的最终位置的。
简化加载。当要向内存中加载可执行文件和共享对象文件时，Linux 加载器为代码段和数据段分配虚拟页并将其标记为无效的（即未缓存的），将页表条目指向目标文件中适当的位置即可。
将一组连续的虚拟页映射到任意一个文件中的任意一个位置叫做内存映射。
简化共享。独立地址空间为操作系统提供了一个管理用户进程与操作系统自身之间共享的一致机制。操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中创建单独的副本。
简化内存分配。当一个进程要求分配堆空间时，操作系统分配 k 个的连续的虚拟内存页面，并将它们映射到物理内存中任意位置的 k 个任意的物理页面。由于页表工作的方式，物理页面不需要是连续的。


#### 虚拟内存作为内存保护的工具

每次 CPU 生成一个虚拟地址时，地址翻译硬件都会读一个 PTE，可以通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问。

三个许可位：

SUP 表示进程是否必须运行在内核模式下才能访问该页。
READ 控制读的权限。
WRITE 控制写的权限。