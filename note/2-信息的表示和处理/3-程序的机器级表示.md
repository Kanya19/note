## 程序编码
### 机器级代码
能够理解汇编代码以及它是如何与原始的C代码相对应的，是理解计算机如何执行程序的关键一步。

1、基本概念：

1、程序计数器 成为%eip，表示将要执行的下一条指令在存储器中的地址。
整数寄存器有8个，可以存储32位的值。

2、条件码寄存器保存着最近执行的算术指令的状态信息，用来实现条件控制。
浮点寄存器也有8个。

3、到了汇编这一层，已经不区分有符号和无符号，各种数据结构在汇编代码中只是连续的字节。

程序存储器包含程序的目标代码，使用虚拟地址寻址。又操作系统转换成最终实际的存储器物理地址。

>各种缓存、主存、显存，共同构成了一个连续的虚拟地址空间。


代码示例
GCC使用自己的格式来产生汇编代码，这种格式被称为GAS(Gnu ASsembler，GNU汇编器)。

    使用 gcc -O2 -S test.c 可以生产test.s汇编文件
    使用 gcc -O2 -c test.c 可以产生test.o文件
    使用 objdump -d test.o 可以看到一些汇编内容。 
    objdump也就是反汇编器，可以将二进制一定程度上还原为汇编代码。

反汇编之后的特性：

IA32的指令长度1到15字节不等，指令编码被设计为常用的指令就比较短，不常用的就比较长

反汇编器仅根据字节序列来确定汇编代码，无需访问原始代码或者汇编。

反汇编器使用的指令名称跟GAS略有不同，例如，省去很多指令结尾的“l”后缀。

### 数据格式
GAS很多指令后面会有一个后缀，例如前面出现的l，这个是小写的L，不是数字1

GAS很多指令后面会有一个后缀，例如前面出现的l，这个是小写的L，不是数字1

### 访问信息
以IA32为例，CPU包含8个32位寄存器。大多数情况下，前六个寄存器都可以看成是通用的寄存器。少数情况下，特定指令会使用特定的寄存器。最后两个寄存器ebp和esp，保存着程序栈的指针，不可随意使用。寄存器的布局如下：（其中前四个寄存器还可以通过ah al等方位低位的两个字节，这是为了兼容早起8086等早起处理器）
>寄存器其实也没什么神秘的，就是一些放数据的地方，只不过位置特殊，在cpu上，所以就是访问特别快。

#### 3.4.1 操作数指示符

一个典型的指令，有一个或多个操作数，就如同函数有一个或多个参数一样。这些操作数的作用是指出源数据的位置，和结果存储的位置。

好比一个C函数 void move(int src, int dest); 把src的值赋给dest，这也就是 movl xxx,xxx 的作用。
而这个源数据怎么得到呢？有下面三种方式：

1、立即数。 开头就是直接给出，无需去内存中查找。例如" alt=" 开头就是直接给出，无需去内存中查找。例如" class="ee_img tr_noresize" eeimg="1">0x123 。

2、寄存器。%加寄存器的名称形式。相当于把整个寄存器看做是数组，寄存器作为索引。

3、存储器引用。源数据在内存中，通过地址来访问。可以将内存看成是大型数组M.

#### 寻址模式


3.4.2 数据传送指令
即mov指令。有两个参数，一个源，一个目标。例如movl %eax,%edx 表示把eax中的值复制到edx中。

IA32中的一个限制，两个参数不可以都为存储器位置，就是说必须要经过寄存器，或者使用立即数。所以代码a=b;的汇编代码不是movl Addra,Addrb，而可能是

>movl Addra,%eax
>
>movl %eax,Addrb

movl指令的五种组合情况：

>movl $0x123,%eax        // 立即数 - 寄存器
>
>movl %eax,%ebx          // 寄存器 - 寄存器
>
>movl (%eax,%ebx),%ecx   // 内存   - 寄存器
>
>movl $0x123, (%eax)     // 立即数 - 内存
>
>movl %eax,(%ebx)        // 寄存器 - 内存

到了这里，终于明白前面simple函数的汇编代码第三行 movl 8(%ebp),%eax 获取xp的意思了。 8(%ebp)表示 8 + %ebp的值代表的地址存储的值。就是把*xp读出来放到eax中。

#### 数据传送实例
按照惯例，所有返回整数或指针的函数，都是通过将结果放在寄存器%eax中来达到目的。

一些临时变量，可能会存储在寄存器中，如果寄存器够用的话。寄存器的访问比存储器访问无疑是要快的多。

根据这个说法，那么现代CPU是不是应该使用更多的寄存器呢？ 知乎上倒是有个问题说这个问题，不太懂，无法辨别。为什么X86的寄存器数量没有随着性能的提升而增加？
通过前面这段内容的学习，我们知道了一些基本的指令，了解了指令的操作数如何访问数据，即寻址模式的几种情况。寻址模式是非常重要的，贯彻整个汇编指令的始终。
函数的栈地址是向下扩展的，压栈会使栈顶地址变小，弹出栈则会使栈顶地址回缩，而回缩后，并不会修改栈中的内存，会遗留以前的数据，等待下一次修改使用。
返回值通过最后修改eax来实现。寄存器比存储器快，这点暂时也不知道如何利用。临时变量比直接使用参数、指针要快？