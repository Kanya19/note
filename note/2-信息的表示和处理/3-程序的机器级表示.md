## 程序编码
### 机器级代码
能够理解汇编代码以及它是如何与原始的C代码相对应的，是理解计算机如何执行程序的关键一步。

1、基本概念：

1、程序计数器 成为%eip，表示将要执行的下一条指令在存储器中的地址。
整数寄存器有8个，可以存储32位的值。

2、条件码寄存器保存着最近执行的算术指令的状态信息，用来实现条件控制。
浮点寄存器也有8个。

3、到了汇编这一层，已经不区分有符号和无符号，各种数据结构在汇编代码中只是连续的字节。

程序存储器包含程序的目标代码，使用虚拟地址寻址。又操作系统转换成最终实际的存储器物理地址。

>各种缓存、主存、显存，共同构成了一个连续的虚拟地址空间。


代码示例
GCC使用自己的格式来产生汇编代码，这种格式被称为GAS(Gnu ASsembler，GNU汇编器)。

    使用 gcc -O2 -S test.c 可以生产test.s汇编文件
    使用 gcc -O2 -c test.c 可以产生test.o文件
    使用 objdump -d test.o 可以看到一些汇编内容。 
    objdump也就是反汇编器，可以将二进制一定程度上还原为汇编代码。

反汇编之后的特性：

IA32的指令长度1到15字节不等，指令编码被设计为常用的指令就比较短，不常用的就比较长

反汇编器仅根据字节序列来确定汇编代码，无需访问原始代码或者汇编。

反汇编器使用的指令名称跟GAS略有不同，例如，省去很多指令结尾的“l”后缀。

### 数据格式
GAS很多指令后面会有一个后缀，例如前面出现的l，这个是小写的L，不是数字1

GAS很多指令后面会有一个后缀，例如前面出现的l，这个是小写的L，不是数字1

### 访问信息
以IA32为例，CPU包含8个32位寄存器。大多数情况下，前六个寄存器都可以看成是通用的寄存器。少数情况下，特定指令会使用特定的寄存器。最后两个寄存器ebp和esp，保存着程序栈的指针，不可随意使用。寄存器的布局如下：（其中前四个寄存器还可以通过ah al等方位低位的两个字节，这是为了兼容早起8086等早起处理器）
>寄存器其实也没什么神秘的，就是一些放数据的地方，只不过位置特殊，在cpu上，所以就是访问特别快。

#### 3.4.1 操作数指示符

一个典型的指令，有一个或多个操作数，就如同函数有一个或多个参数一样。这些操作数的作用是指出源数据的位置，和结果存储的位置。

好比一个C函数 void move(int src, int dest); 把src的值赋给dest，这也就是 movl xxx,xxx 的作用。
而这个源数据怎么得到呢？有下面三种方式：

1、立即数。 开头就是直接给出，无需去内存中查找。例如" alt=" 开头就是直接给出，无需去内存中查找。例如" class="ee_img tr_noresize" eeimg="1">0x123 。

2、寄存器。%加寄存器的名称形式。相当于把整个寄存器看做是数组，寄存器作为索引。

3、存储器引用。源数据在内存中，通过地址来访问。可以将内存看成是大型数组M.

#### 寻址模式


3.4.2 数据传送指令
即mov指令。有两个参数，一个源，一个目标。例如movl %eax,%edx 表示把eax中的值复制到edx中。

IA32中的一个限制，两个参数不可以都为存储器位置，就是说必须要经过寄存器，或者使用立即数。所以代码a=b;的汇编代码不是movl Addra,Addrb，而可能是

>movl Addra,%eax
>
>movl %eax,Addrb

movl指令的五种组合情况：

>movl $0x123,%eax        // 立即数 - 寄存器
>
>movl %eax,%ebx          // 寄存器 - 寄存器
>
>movl (%eax,%ebx),%ecx   // 内存   - 寄存器
>
>movl $0x123, (%eax)     // 立即数 - 内存
>
>movl %eax,(%ebx)        // 寄存器 - 内存

到了这里，终于明白前面simple函数的汇编代码第三行 movl 8(%ebp),%eax 获取xp的意思了。 8(%ebp)表示 8 + %ebp的值代表的地址存储的值。就是把*xp读出来放到eax中。

#### 数据传送实例
按照惯例，所有返回整数或指针的函数，都是通过将结果放在寄存器%eax中来达到目的。

一些临时变量，可能会存储在寄存器中，如果寄存器够用的话。寄存器的访问比存储器访问无疑是要快的多。

根据这个说法，那么现代CPU是不是应该使用更多的寄存器呢？ 知乎上倒是有个问题说这个问题，不太懂，无法辨别。为什么X86的寄存器数量没有随着性能的提升而增加？
通过前面这段内容的学习，我们知道了一些基本的指令，了解了指令的操作数如何访问数据，即寻址模式的几种情况。寻址模式是非常重要的，贯彻整个汇编指令的始终。
函数的栈地址是向下扩展的，压栈会使栈顶地址变小，弹出栈则会使栈顶地址回缩，而回缩后，并不会修改栈中的内存，会遗留以前的数据，等待下一次修改使用。
返回值通过最后修改eax来实现。寄存器比存储器快，这点暂时也不知道如何利用。临时变量比直接使用参数、指针要快？

#### 加载有效地址 lea
lea即 Load Effective Address，独成一类。该指令实际是mov的变形，指令形式是从存储器读数据到寄存器，但实际上并不会访问存储器，而只是将地址存储到目标寄存器。如同C语言中的&S结果。

#### 一元和二元操作
第二类为一元操作，一元操作即只有一个操作数，即使源也是目标。如图3.7中的 Inc dec neg not指令。

第三类为二元操作，有两个操作数，且第二个操作数既作为源也作为目标。 如同C中的 x += y 中的x既作为源，又作为目标。与mov同样的，两个操作数不可以同时为存储器位置。

### 移位操作
第四类移位操作。操作数k取值范围为0到31，可以是立即数，或者存放在单字节寄存器中（即前四个寄存器的地位中）。两个左移是一样的，都是右边填充0 。右移则区分算术右移和逻辑右移。


>所以左移也有两个指令是强迫症保持对称吗？

常数的乘法常常会优化为加法和移位的组合，当然对于无法拆分的则只能直接使用imul指令。例如x*48 可以拆解为两条指令 x*=3;x<<4 而x*3又可以使用 lea (%eax, %eax, 2), %edx 来实现

>利用寻址方式来实现一些固定的乘法。由于寻址模式里面的s只能取值1 2 4 8，所以该方式就只能实现一些特定的乘法， 例如3x, 5x, 9x等。


### 特殊的算术操作

上图的imull和mull常规来说是需要两个操作符的，但是这里是但操作符。当他们为单操作符的时候，就是计算64位的乘法。此法要求另一个操作数要提前存储在%eax中。乘法的结果高位存在%edx中，地位存储在%eax中组合成一个64位的数字。

> 目前为止%eax有三个特殊用法了：
 
1.整数型返回值，需要放入到%eax中

2.imull和mull的单操作数模式，使用%eax中数据作为乘数，结果的低位也存储到%eax中

3.idivl和divl被除数的低位在%eax中。


### 控制
程序执行的一个很重要的部分就是控制执行的顺序，像条件分支，循环，switch等等。汇编代码中基本上就只有个跳转，相当于C中的goto。所以后面将可以看到一些实例C代码的汇编，同其goto实现版本基本是一致的。

>学C++的时候都说goto不好，建议不要用，是因为程序员容易用的不好？主要是容易滥用导致控制流混乱。结构良好的goto，可以很好的统一在函数结尾释放资源、处理失败情况等。

#### 条件码
CPU的四个条件码寄存器：

1、CF：进位标志。最近的操作使最高位产生了进位。用于无符号数溢出

2、ZF：零标志。最近的操作结果是0 。

3、SF：符号标志。 是否为负数。

4、OF：溢出标志。最近的操作导致二进制补码溢出

例如C代码 t = a + b， 该指令操作完成后就会设置以上的四个标志位。其中：

1、CF：(unsigned t) < (unsigned a)

2、ZF：t == 0

3、SF：t < 0 负数

4、OF：(a < 0 == b < 0) && (t < 0 != a < 0)

leal指令不会改变条件码，因为它只操作地址。对于逻辑操作，xorl （异或）进位标志和溢出标志都设置成0，移位操作则进位标志设置为最后一个被移除的位，溢出标志则为0 。

#### 跳转指令编码

跟前面set的后缀完全一致，就是set换成j 。jmp完整指令则是不判断条件。其他指令则是在满足条件的情况下跳转。这里的Label也如同C语言中Goto的标签一样。

jmp *Operand指令则是跳转到寄存器或者内存中的某个地址去。 例如 jmp *%eax, jmp *(eax) 寻址方式则是与mov等指令一致。

跳转指令的常见做法是：目标地址相对PC（指令计数器）的。也就是是比如当前的PC是 0x123, 则想要调到0x126地址去，编码会是jmp 0x3

一般来说PC的值是当前指令的下一条指令的地址，而不是当前指令的地址，这是因为处理器会先将PC更新，然后才开始执行指令。

汇编代码中可能会有.p2align 4,,7类似的指令，这是条汇编器的命令，它会使后面的指令地址从16的倍数开始，而最多浪费7个字节。这有什么好处呢？它能够让处理器更优化地使用指令高速缓存存储器。

### 翻译条件转移

    if (test-expr)
        then-statement
    else
        else-statement
    以上语句翻译成goto版本为：
    t = test-expr
    if (t)
        goto True;
    else-statement;
    goto Dne;
    True:
    then-statement
Done:

汇编语言正是以goto版本来翻译if语句的。

>为什么用goto，我想是因为汇编及底层只有顺序和跳转两个方式。就是说只有goto这种方式，高级语言的控制结构必须转成想应的goto结构。

###  循环
for、while和do-while循环，一般在编译成汇编的过程中，都会转换成do-while的循环结构。do-while 循环结构有下面的形式：

    do
    body-statement
    while(test-exp) 
    这很容易翻译成汇编代码的结构如下：

    loop:
    body-statement
    t = test-exp
    if (t)
        goto loop

while循环如何翻译成上面的形式？

    while (test-exp)
        body-statement
    可以翻译成：
    t = test-exp;
    if (!t)
        goto done;
    loop:
    body-statement
    t = test-exp
    if (t)
        goto loop;
    done:

switch语句

GCC根据开关情况的数量和开关情况值的稀少程度来翻译开关语句。当开关情况数量比较多，并且值的范围跨度比较小时，就会使用跳转表。跳转表可以使得跳转时间与开关数量无关。

>这么说跳转表来类似一个map，直接索引到目标，多个if-else则像是vector在遍历。
这里也说到了使用跳转表是有条件的，并不是switch必然会使用。在不使用调整表的情况下，两者的汇编代码其实是一致的。所以以后不能无脑说switch比if快了，得有理有据。


### 过程

一个过程调用，就是指函数调用，包括参数传递、指令转移、局部变量分配空间及释放。这些都是通过操纵程序栈来实现的。

>关于帧栈，我们目前知道以下几点：
栈使用%ebp %esp一对寄存器来表示栈底，和栈顶
栈顶地址较小，栈是往下扩展的。
函数的参数入栈的顺序和参数顺序是反的，即第一个参数是最后入栈。

#### 栈帧结构
栈帧的范围由两个指针来确定范围，寄存器%ebp为帧指针，寄存器%esp为栈指针。在单个函数的执行过程中，%ebp是不会移动的，%esp则会因为局部变量等入栈而下移。由于%ebp的稳定，所以很多信息的访问都是基于%ebp的。

函数P调用函数Q，Q的参数放在P的栈中，为了执行Q结束后，Q调用后的下一条指令的地址也会入栈，以便返回后继续执行，该地址由call自动入栈。

局部变量也不是非得在栈中，有些可以只在寄存器中，毕竟寄存器更快。但是有些情况不得不用栈：

寄存器数量有限，不够放所有的局部变量

局部变量是数组或者结构体，必须要通过相关引用来访问（这个后面后说到）

即使寄存器够用，但如果对一个使用&来获取地址，则必须放在栈中以便产生一个地址。

>看来当局部变量少的时候，应该尽量减少使用&相关的操作。

pushl 和 popl是一对入栈和出栈的指令，可以方便的操作单个数据。而subl $16,%esp这种操作则可以直接分配指定的空间，也可以使addl来释放空间。

#### 转移控制

返回地址，正如前面所说，压完参数后，会压入函数返回后继续执行的地址，以便后续执行。此地址由call指令入栈，无法手动入栈。

参数入栈是逆序的，

当进入新函数的时候，第一件事就是将之前的帧指针(%ebp)入栈。这是为了函数返回的时候恢复上个函数的帧栈。（方法很简单，就是先把当前esp移到当前ebp的位置，再pop存储的ebp值给当前%ebp）

涉及后面的寄存器使用规范，马上就要讲到。

第三点用汇编指令就是，也等价于一个简短指令leave

####  寄存器使用惯例

IA32寄存器有三条基本的使用惯例

寄存器%eax,%edx,%ecx为调用者保存 （可以记成 ADC ）

%ebx,%esi,%edi为被调用者保存。

%ebp,%esp特定规则

>啥叫调用者保存？就是说举个例子，函数A调用函数B的情况下，A就是调用者，如果A使用了%eax,%edx,%ecx其中的寄存器，并且不想被B给覆盖，就需要在调用B之前，自己压栈。而在B执行过程中，则可以安全的使用这三个寄存器。
>
>反过来，被调用者保存就是说，函数B需要使用%ebx,%esi,%edi的时候，需要先将他们入栈，函数结尾还得从栈中将他们回复。
>
>为什么分成两组不同的方法呢？ 这是一种效率上的平衡，为了尽量减少栈的读写和数据的安全的平衡。 首先，寄存器中的值是否需要保持，其实B是不知道的，A自己知道。所以按理说由A来保持所有的寄存器是最好的。但是函数B也未必会使用到所有的寄存器，无脑全部入栈就很浪费。 而adc三个寄存器使用频率非常高，函数基本上都会使用到，可以认为函数B必然会用到，所以函数A负责处理他们。 后三个寄存器相对来说使用概率要低一点。A的心声：万一B不用这几个，岂不是就省了一次读写栈，岂不美哉？

#### 过程实例

在调用函数时，常常会看到汇编代码中，有类似这种代码：

>subl $24,%esp          // 栈指针下移24个字节，分配空间，单无人使用
>
>leal -4(%ebp),%eax
>
>push %eax              // 再开始参数入栈
>
>call XXX               // 函数调用

#### 递归过程

递归跟普通函数调用上，栈其实没什么区别，每次递归，栈也都会重新分配帧栈空间。

> leal这个指令不仅可以用来计算地址，实际上还能用来做简单的加法和乘法。用他来做加法还能同时三个寄存器和两个常量。例如，要将%edx中的数+2，再加%ecx的值，并存储到%eax中，使用add，mov如下： addl $2,%edx movl %edx,%eax addl %ecx,%eax 而用leal指令，则是：leal $2(%edx,%ecx),%eax一条指令搞定。 这个是前面mov处将到的间接寻址的完整形式：Imm(A,R,S) ，mov是对计算出的值当成地址，并取出地址中的值，而leal则只计算出地址，所以可以用来实现上述功能

### 数组的分配和访问

对于C语言，我们知道：