## 程序编码
### 机器级代码
能够理解汇编代码以及它是如何与原始的C代码相对应的，是理解计算机如何执行程序的关键一步。

1、基本概念：

1、程序计数器 成为%eip，表示将要执行的下一条指令在存储器中的地址。
整数寄存器有8个，可以存储32位的值。

2、条件码寄存器保存着最近执行的算术指令的状态信息，用来实现条件控制。
浮点寄存器也有8个。

3、到了汇编这一层，已经不区分有符号和无符号，各种数据结构在汇编代码中只是连续的字节。

程序存储器包含程序的目标代码，使用虚拟地址寻址。又操作系统转换成最终实际的存储器物理地址。

>各种缓存、主存、显存，共同构成了一个连续的虚拟地址空间。


代码示例
GCC使用自己的格式来产生汇编代码，这种格式被称为GAS(Gnu ASsembler，GNU汇编器)。

    使用 gcc -O2 -S test.c 可以生产test.s汇编文件
    使用 gcc -O2 -c test.c 可以产生test.o文件
    使用 objdump -d test.o 可以看到一些汇编内容。 
    objdump也就是反汇编器，可以将二进制一定程度上还原为汇编代码。

反汇编之后的特性：

IA32的指令长度1到15字节不等，指令编码被设计为常用的指令就比较短，不常用的就比较长

反汇编器仅根据字节序列来确定汇编代码，无需访问原始代码或者汇编。

反汇编器使用的指令名称跟GAS略有不同，例如，省去很多指令结尾的“l”后缀。

### 数据格式
GAS很多指令后面会有一个后缀，例如前面出现的l，这个是小写的L，不是数字1

GAS很多指令后面会有一个后缀，例如前面出现的l，这个是小写的L，不是数字1

### 访问信息
以IA32为例，CPU包含8个32位寄存器。大多数情况下，前六个寄存器都可以看成是通用的寄存器。少数情况下，特定指令会使用特定的寄存器。最后两个寄存器ebp和esp，保存着程序栈的指针，不可随意使用。寄存器的布局如下：（其中前四个寄存器还可以通过ah al等方位低位的两个字节，这是为了兼容早起8086等早起处理器）
>寄存器其实也没什么神秘的，就是一些放数据的地方，只不过位置特殊，在cpu上，所以就是访问特别快。

#### 3.4.1 操作数指示符

一个典型的指令，有一个或多个操作数，就如同函数有一个或多个参数一样。这些操作数的作用是指出源数据的位置，和结果存储的位置。

好比一个C函数 void move(int src, int dest); 把src的值赋给dest，这也就是 movl xxx,xxx 的作用。
而这个源数据怎么得到呢？有下面三种方式：

1、立即数。 开头就是直接给出，无需去内存中查找。例如" alt=" 开头就是直接给出，无需去内存中查找。例如" class="ee_img tr_noresize" eeimg="1">0x123 。

2、寄存器。%加寄存器的名称形式。相当于把整个寄存器看做是数组，寄存器作为索引。

3、存储器引用。源数据在内存中，通过地址来访问。可以将内存看成是大型数组M.

#### 寻址模式

一个寻址表达式的完整形态为[公式] ，表达的地址是：[公式] 。其中

1、Imm表示写死的地址， 这里不需要加 $前缀，与立即数区别
2、[公式] 表示对应寄存器中存储的值。
s表示缩放因子，取值范围为1,2,4,8。
这四个部分都可以省略

>寻址说起来吓人，其实就是根据前面那个公式来计算一个地址，然后通过M[Addr]来得到地址所在内存的值。就好比计算数组下标，然后取数组中的值。
