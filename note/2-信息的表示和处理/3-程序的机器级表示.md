## 程序编码
### 机器级代码
能够理解汇编代码以及它是如何与原始的C代码相对应的，是理解计算机如何执行程序的关键一步。

1、基本概念：

1、程序计数器 成为%eip，表示将要执行的下一条指令在存储器中的地址。
整数寄存器有8个，可以存储32位的值。

2、条件码寄存器保存着最近执行的算术指令的状态信息，用来实现条件控制。
浮点寄存器也有8个。

3、到了汇编这一层，已经不区分有符号和无符号，各种数据结构在汇编代码中只是连续的字节。

程序存储器包含程序的目标代码，使用虚拟地址寻址。又操作系统转换成最终实际的存储器物理地址。

>各种缓存、主存、显存，共同构成了一个连续的虚拟地址空间。


代码示例
GCC使用自己的格式来产生汇编代码，这种格式被称为GAS(Gnu ASsembler，GNU汇编器)。

    使用 gcc -O2 -S test.c 可以生产test.s汇编文件
    使用 gcc -O2 -c test.c 可以产生test.o文件
    使用 objdump -d test.o 可以看到一些汇编内容。 
    objdump也就是反汇编器，可以将二进制一定程度上还原为汇编代码。

反汇编之后的特性：

IA32的指令长度1到15字节不等，指令编码被设计为常用的指令就比较短，不常用的就比较长

反汇编器仅根据字节序列来确定汇编代码，无需访问原始代码或者汇编。

反汇编器使用的指令名称跟GAS略有不同，例如，省去很多指令结尾的“l”后缀。

### 数据格式
GAS很多指令后面会有一个后缀，例如前面出现的l，这个是小写的L，不是数字1

GAS很多指令后面会有一个后缀，例如前面出现的l，这个是小写的L，不是数字1

### 访问信息
以IA32为例，CPU包含8个32位寄存器。大多数情况下，前六个寄存器都可以看成是通用的寄存器。少数情况下，特定指令会使用特定的寄存器。最后两个寄存器ebp和esp，保存着程序栈的指针，不可随意使用。寄存器的布局如下：（其中前四个寄存器还可以通过ah al等方位低位的两个字节，这是为了兼容早起8086等早起处理器）
>寄存器其实也没什么神秘的，就是一些放数据的地方，只不过位置特殊，在cpu上，所以就是访问特别快。

#### 3.4.1 操作数指示符

一个典型的指令，有一个或多个操作数，就如同函数有一个或多个参数一样。这些操作数的作用是指出源数据的位置，和结果存储的位置。

好比一个C函数 void move(int src, int dest); 把src的值赋给dest，这也就是 movl xxx,xxx 的作用。
而这个源数据怎么得到呢？有下面三种方式：

1、立即数。 开头就是直接给出，无需去内存中查找。例如" alt=" 开头就是直接给出，无需去内存中查找。例如" class="ee_img tr_noresize" eeimg="1">0x123 。

2、寄存器。%加寄存器的名称形式。相当于把整个寄存器看做是数组，寄存器作为索引。

3、存储器引用。源数据在内存中，通过地址来访问。可以将内存看成是大型数组M.

#### 寻址模式


3.4.2 数据传送指令
即mov指令。有两个参数，一个源，一个目标。例如movl %eax,%edx 表示把eax中的值复制到edx中。

IA32中的一个限制，两个参数不可以都为存储器位置，就是说必须要经过寄存器，或者使用立即数。所以代码a=b;的汇编代码不是movl Addra,Addrb，而可能是

>movl Addra,%eax
>
>movl %eax,Addrb

movl指令的五种组合情况：

>movl $0x123,%eax        // 立即数 - 寄存器
>
>movl %eax,%ebx          // 寄存器 - 寄存器
>
>movl (%eax,%ebx),%ecx   // 内存   - 寄存器
>
>movl $0x123, (%eax)     // 立即数 - 内存
>
>movl %eax,(%ebx)        // 寄存器 - 内存

到了这里，终于明白前面simple函数的汇编代码第三行 movl 8(%ebp),%eax 获取xp的意思了。 8(%ebp)表示 8 + %ebp的值代表的地址存储的值。就是把*xp读出来放到eax中。

#### 数据传送实例
按照惯例，所有返回整数或指针的函数，都是通过将结果放在寄存器%eax中来达到目的。

一些临时变量，可能会存储在寄存器中，如果寄存器够用的话。寄存器的访问比存储器访问无疑是要快的多。

根据这个说法，那么现代CPU是不是应该使用更多的寄存器呢？ 知乎上倒是有个问题说这个问题，不太懂，无法辨别。为什么X86的寄存器数量没有随着性能的提升而增加？
通过前面这段内容的学习，我们知道了一些基本的指令，了解了指令的操作数如何访问数据，即寻址模式的几种情况。寻址模式是非常重要的，贯彻整个汇编指令的始终。
函数的栈地址是向下扩展的，压栈会使栈顶地址变小，弹出栈则会使栈顶地址回缩，而回缩后，并不会修改栈中的内存，会遗留以前的数据，等待下一次修改使用。
返回值通过最后修改eax来实现。寄存器比存储器快，这点暂时也不知道如何利用。临时变量比直接使用参数、指针要快？

#### 加载有效地址 lea
lea即 Load Effective Address，独成一类。该指令实际是mov的变形，指令形式是从存储器读数据到寄存器，但实际上并不会访问存储器，而只是将地址存储到目标寄存器。如同C语言中的&S结果。

#### 一元和二元操作
第二类为一元操作，一元操作即只有一个操作数，即使源也是目标。如图3.7中的 Inc dec neg not指令。

第三类为二元操作，有两个操作数，且第二个操作数既作为源也作为目标。 如同C中的 x += y 中的x既作为源，又作为目标。与mov同样的，两个操作数不可以同时为存储器位置。

### 移位操作
第四类移位操作。操作数k取值范围为0到31，可以是立即数，或者存放在单字节寄存器中（即前四个寄存器的地位中）。两个左移是一样的，都是右边填充0 。右移则区分算术右移和逻辑右移。


>所以左移也有两个指令是强迫症保持对称吗？

常数的乘法常常会优化为加法和移位的组合，当然对于无法拆分的则只能直接使用imul指令。例如x*48 可以拆解为两条指令 x*=3;x<<4 而x*3又可以使用 lea (%eax, %eax, 2), %edx 来实现

>利用寻址方式来实现一些固定的乘法。由于寻址模式里面的s只能取值1 2 4 8，所以该方式就只能实现一些特定的乘法， 例如3x, 5x, 9x等。


### 特殊的算术操作

上图的imull和mull常规来说是需要两个操作符的，但是这里是但操作符。当他们为单操作符的时候，就是计算64位的乘法。此法要求另一个操作数要提前存储在%eax中。乘法的结果高位存在%edx中，地位存储在%eax中组合成一个64位的数字。

> 目前为止%eax有三个特殊用法了：
 
1.整数型返回值，需要放入到%eax中

2.imull和mull的单操作数模式，使用%eax中数据作为乘数，结果的低位也存储到%eax中

3.idivl和divl被除数的低位在%eax中。


### 控制
程序执行的一个很重要的部分就是控制执行的顺序，像条件分支，循环，switch等等。汇编代码中基本上就只有个跳转，相当于C中的goto。所以后面将可以看到一些实例C代码的汇编，同其goto实现版本基本是一致的。

>学C++的时候都说goto不好，建议不要用，是因为程序员容易用的不好？主要是容易滥用导致控制流混乱。结构良好的goto，可以很好的统一在函数结尾释放资源、处理失败情况等。

#### 条件码
CPU的四个条件码寄存器：

1、CF：进位标志。最近的操作使最高位产生了进位。用于无符号数溢出

2、ZF：零标志。最近的操作结果是0 。

3、SF：符号标志。 是否为负数。

4、OF：溢出标志。最近的操作导致二进制补码溢出

例如C代码 t = a + b， 该指令操作完成后就会设置以上的四个标志位。其中：

1、CF：(unsigned t) < (unsigned a)

2、ZF：t == 0

3、SF：t < 0 负数

4、OF：(a < 0 == b < 0) && (t < 0 != a < 0)

leal指令不会改变条件码，因为它只操作地址。对于逻辑操作，xorl （异或）进位标志和溢出标志都设置成0，移位操作则进位标志设置为最后一个被移除的位，溢出标志则为0 。