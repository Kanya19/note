并发编程
=================
### 为什么要并发

1. 并发是一种解耦策略，它帮助我们把做什么（目的）和何时（时机）做分解开

2. 解耦目的与时机能明显地改进应用程序的吞吐量和结构

3. 单线程程序许多时间花在等待web套接字I/O结束上面，通过采用同时访问多个站点的多线程算法，就能改进性能

4. 常见的迷思和误解

* 并发总能改进性能：只在多个线程或处理器之间能分享大量等待时间的时候管用
* 编写并发程序无需修改设计：可能与单线程系统的设计极不相同
* 在采用web或ejb容器时，理解并发问题并不重要
5. 有关编写并发软件的中肯的说法：

* 并发会在性能和编写额外代码上增加一些开销
* 正确的并发是复杂的，即使对于简单的问题也是如此
* 并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待
* 并发常常需要对设计策略的根本性修改


### 挑战
1. 线程在执行代码时有许多可能路径可行，有些路径会产生错误的结果

### 并发防御原则

1. 单一权责原则（SRP）：方法/类/组件应当只有一个修改的理由

* 并发相关代码有自己的开发、修改和调优生命周期
* 开发相关代码有自己要对付的挑战，和非并发相关代码不同
* 即使没有周边应用程序增加的负担，写得不好的并发代码可能的出错方式数量也已经足具有挑战性
* 建议：分离并发相关代码与其他代码
2. 推论：限制数据作用域

* 采用synchronized关键字在代码中保护一块使用共享对象的临界区（critical section）
* 建议：谨记数据封闭；严格限制对可能被共享的数据的访问
3. 推论：使用数据复本

* 一开始就避免共享数据，复制对象并以只读方式对待，或复制对象，从多个线程收集所有复本的结果，并在单个线程中合并这些结果
4. 推论：线程应尽可能地独立

* 让每个线程在自己的世界中存在，不与其他线程共享数据
* 建议：尝试将数据分解到可被独立线程（可能在不同处理器上）操作的独立子集


### 了解Java库

1. 要注意：

* 使用类库提供的线程安全群集
* 使用executor框架（executor framework）执行无关任务
* 尽可能使用非锁定解决方案
* 有几个类并不是线程安全的


### 了解执行模型

1. 定义

* 限定资源：并发环境中有着固定尺寸或数量的资源
* 互斥：每一时刻仅有一个线程能访问共享数据或共享资源
* 线程饥饿：一个或一组线程在很长时间内或永久被禁止
* 死锁：两个或多个线程互相等待执行结束。每个线程都拥有其他线程需要的资源，行不到其他线程拥有的资源，就无法终止
* 活锁：执行次序一致的线程，每个都想要起步，但发现其他线程已经“在路上”。由于竞步的原因，线程会持续尝试起步，但在很长时间内却无法如愿，甚至永远无法启动
2. 生产者-消费者模型：一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者消费者之间的队列是一种限定资源
3. 读者-作者模型：协调读者线程，不去读作者线程正在更新的信息（反之亦然），这是一种辛苦的平衡工作，作者线程倾向于长期锁定许多读者纯种，从而导致吞吐量问题
4. 宴席哲学家
5. 建议学习这些基础算法，理解其解决方案

### 警惕同步方法之间的依赖
1. 同步方法之间的依赖会导致并发代码中的狡猾缺陷，建议避免使用一个共享对象的多个方法
2. 基于客户端的锁定：客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码
3. 基于服务端的锁定：在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新方法
4. 适配服务端：创建执行锁定的中间层。这是一种基于服务端的锁定的例子，但不修改原始服务端代码

### 保持同步区域微小
1. 同一个锁维护的所有代码区域在任一时刻保证只有一个线程执行，因为它们带来了延迟和额外开销，临界区应该被保护起来，应该尽可能少地设计临界区

### 很维编写正确的关闭代码
1. 平静关闭很难做到，常见问题与死锁有关，线程一直等待永远不会到来的信号
2. 建议：尽早考虑关闭问题，尽早令其工作正常

### 测试线程代码
1. 建议：编写有潜力曝露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行。如果测试失败，跟踪错误。别因为后来测试通过了后来的运行就忽略失败
2. 将伪失败看作可能的线程问题：线程代码导致“不可能失败的”失败，不要将系统错误归咎于偶发事件
3. 先使非线程代码可工作：不要同时追踪非线程缺陷和线程缺陷，确保代码在线程之外可工作
4. 编写可插拔的线程代码，能在不同的配置环境下运行
5. 编写可调整的线程代码：允许线程依据吞吐量和系统使用率自我调整
6. 运行多于处理器数量的线程：任务交换越频繁，越有可能找到错过临界区域导致死锁的代码
7. 在不同平台上运行：尽早并经常地在所有目标平台上运行线程代码
8. 装置试错代码：增加对Object. wait()、Object. sleep()、Object. yield()、Object. priority()等方法的调用，改变代码执行顺序，硬编码或自动化