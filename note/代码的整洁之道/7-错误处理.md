错误处理
=================
>错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法

### 使用异常而非返回码
1. 遇到错误时，最好抛出一个异常。调用代码很整洁，其逻辑不会被错误处理搞乱

### 先写Try-Catch-Finally语句
1. 异常的妙处之一是，它们在程序中定义了一个范围。执行try-catch-finally语句中try部分的代码时，你是在表明可随时取消执行，并在catch语句中接续
2. 在某种意义上，try代码块就像是事务，catch代码块将程序维持在一种持续状态
3. 在编写可能抛出异常的代码时，最好先写try-catch-finally语句，能帮你定义代码的用户应该期待什么，无论try代码块中执行的代码出什么错都一样

### 使用不可控异常
1. 可控异常的代价就是违反开放/闭合原则，得在catch语句和抛出异常处之间的每个方法签名中声明该异常
2. 可控异常意味着对软件中较低层级的修改，都将波及较高层级的签名

### 给出异常发生的环境说明
1. 抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所
2. 应创建信息充分的错误消息，并和异常一起传递出去

### 依调用者需要定义异常类
1. 最重要的考虑是它们如何被捕获
2. 将第三方API打包是个良好的实践手段，降低了对每个第三方的依赖，也有助于模拟第三方调用

### 定义常规流程
1. 特例模式（SPECIAL CASE PATTERN,[Fowler]），创建一个类或配置一个对象，用来处理特例，异常行为被封装到特例对象中

### 别返回null值
1. 返回null值，基本是在给自己增加工作量，也是在给调用者添乱，只要有一处没检查null值，应用程序就会失控

### 别传递null值
1. 将null值传递给其他方法更糟糕，除非API要求你向它传递null值，否则就要尽可能避免传递null值